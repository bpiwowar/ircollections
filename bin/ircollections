#!/usr/bin/python

#
# Main file to access IR tasks
# and manage them
#

# id=trec.2003/web/distillation; bin/ircollections get $id; echo " **** VS ****"; scripts/get-tasks $id; echo

import urllib
from lxml import etree
from lxml.builder import E, ElementMaker

import sys
import getopt
import os.path
from os.path import dirname, normpath, join
import traceback
import tempfile
import tarfile
import gzip
import shutil
import re

########################
### Global variables ###
########################

# The main IR Collections directory
ircdir=os.path.dirname(os.path.abspath(os.path.dirname(os.path.realpath(__file__))))
ircnsNone = {None : "http://ircollections.sourceforge.net"}
ircns = { "irc": "http://ircollections.sourceforge.net" }
E = ElementMaker(namespace="http://ircollections.sourceforge.net", nsmap=ircnsNone)


#########################
### Utility functions ###
#########################

## {{{ http://code.activestate.com/recipes/552732/ (r1)
def rm_rf(d):
    log("Removing directory %s" % d)
    for path in (os.path.join(d,f) for f in os.listdir(d)):
        if os.path.isdir(path):
            rm_rf(path)
        else:
            os.unlink(path)
    os.rmdir(d)
## end of http://code.activestate.com/recipes/552732/ }}}


def log(message):
    sys.stderr.write(message)
    sys.stderr.write("\n")



def find(task, name):
    """ Find the first task ancestor that has an element of a given name
    """
    l = task.xpath("ancestor-or-self::irc:task[irc:%s][1]/irc:%s" % (name, name), namespaces=ircns)
    if len(l) == 0: raise Exception("Could not find a definition for task '%s'" % (name))
    return l[0]


def findDefinition(doc, id, parentType, type):
    """Find a definition for a given id
    """
    xpath = "//irc:%s/irc:%s[@id='%s']" % (parentType, type, id)
    el = doc.xpath(xpath, namespaces=ircns)
    if len(el) != 1: raise Exception("Could not find a %s/%s with id %s" % (parentType, type, id))
    el = el[0]
    alias = el.get("alias")
    if not alias is None:
        a = findDefinition(doc, alias, parentType, type)
        a.append(el)
        return a
    return [el]

def absolutePath(*args):
    """Returns the absolute path of a path relative to the IR collections base directory"""
    return os.path.join(ircdir, os.path.join(*args))

def xpath(node, path):
    return node.xpath(path, namespaces = ircns)

def xpath1(node, path):
    return node.xpath(path, namespaces = ircns)[0]


###############
### Classes ###
###############

class Tasks():
    def __init__(self, dir):
        tasksfile=os.path.join(dir,os.path.join("etc", "tasks.xml"))
        self.colls = etree.parse(os.path.join(dir,os.path.join("etc", "collections.xml")))
        self.doc = etree.parse(tasksfile)

        log("Using the task file '%s'" % tasksfile)
        
        # Pre-compute the list of available tasks 
        # and get their corresponding XML node
        self.tasks = {}
        for e in xpath(self.doc, '//irc:task[not(@abstract)]'):
            name = None
            for p in xpath(e, "ancestor-or-self::irc:task"):
                if name is None: name = p.get("name")
                else: name = "%s/%s" % (name, p.get("name"))
            self.tasks[name] =  e
        
        
    def getCollectionBasePath(self, id):
        """Get the documents base path in order to create an absolute path to document files
        """
        priority = 0
        path = None
        for c in xpath(self.colls, "/collections/basepath"):
            if c.get("pattern") is None:
                if priority <= 0: path=c.text
        return path
        
    def getAllTasks(self):
        """ Get the list of all non abstract tasks
        """
        return self.tasks
        
    def getTask(self, id):
        return Task(self.doc, self.tasks.get(id))


class Documents:
    """This defines a set of documents
    """
    def __init__(self, doc, id):
        collection = findDefinition(doc, id, "collections", "collection")
        
        if len(collection) == 0:
            raise Exception("Could not find collection with id [%s]" % id)
        
        if len(collection) > 1:
            self.aliased_from = collection[-1].get("id")
        
        self.collection = collection[0]
        self.type = self.collection.get("type")
        self.id = id
        
        ref = self.collection.get("ref")
        if ref is None: self.ref = []
        else: self.ref = ref.split(" ")
       
        # Get patterns
        for e in xpath(doc, "//irc:collection[@pattern]"):
            if re.match(e.get("pattern"), self.collection.get("id")):
                type = e.get("type")
                if not type is None: self.type = type
                

    def toXML(self):
        path = absolutePath("cols", self.id)
        return E.documents(type=self.type, path=path, id=self.id)
    
class Topics:
    def __init__(self, doc, id):
        topics = findDefinition(doc, id, "topics-sets", "topics")[0]
        self.path = absolutePath(topics.get("path"))
        self.url = xpath1(topics, "irc:url")
        self.id = id

    def toXML(self):
        return E.topics(path=self.path, id=self.id)
    
class Assessments:
    def __init__(self, doc, id):
        qrels = findDefinition(doc, id, "assessments", "qrels")[0]
        if qrels is None:
            raise Exception("Could not find assessments with id [%s]" % id)
        self.path = absolutePath(qrels.get("path"))
        self.url = xpath1(qrels, "irc:url")
        self.id = id
        self.type = qrels.get("type")
        
    def restrict(self, documents):
        self.documents = documents
        self.origPath = self.path
        self.path = "%s.R.%s" % (self.path, documents.id)
        self.id = "%s@%s" % (self.id, documents.id)
        
    def toXML(self):
        return E.qrels(path=self.path, id=self.id)

    def filter(self, inpath, outpath):
        log("Filtering assessments for sub-collection %s" % self.documents.id)
        pattern = xpath1(self.documents.collection, "irc:document").get("pattern")
        m = re.compile(pattern)
        
        if self.type == "trec":
            self.filter_trec(m, inpath, outpath)
        else: 
            raise Exception("Cannot filter assessments of type %s" % self.type)
            
    def filter_trec(self, m, inpath, outpath):
        tmp = "%s.tmp" % outpath
        
        f = file(tmp, "w")
        for line in file(inpath, "r"):
            filename=line.split(" ")[2]
            if m.match(filename): 
                f.write(line)
        f.close()
        
        shutil.move(tmp, outpath)
        
class Task():
    """Object representing a set task
    """
    def __init__(self, doc, xml):
        self.documents = Documents(doc, find(xml, "collection").text)
        self.assessments = Assessments(doc, find(xml, "qrels").text)
        self.topics = Topics(doc, find(xml, "qrels").text)
    
    def toXML(self):
        root = E.task(
            self.documents.toXML(),
            self.topics.toXML(),
            self.assessments.toXML()
        )
        return root
        

    def restrict(self, doc, docsid):
        if not docsid in self.documents.ref:
            log("Available: %s" % self.documents.ref)
            raise Exception("No [%s] sub-collection" % docsid)
            
        self.documents = Documents(doc, docsid)
        if self.documents is None: raise Exception("Could not find documents [%s]" % docsid)
        
        self.assessments.restrict(self.documents)
        

############
### List ###
############

def listAllTasks(tasks):
    """ List all tasks
    """
    tasks = tasks.getAllTasks()
    maxLen = 0
    for e in tasks.keys():
        l = len(e)
        if maxLen < l: maxLen = l

    f = "%%-%ds %%s" % (maxLen + 3)
    for name, e in tasks.iteritems():
        print f % (name, e.get("description"))

###########
### Get ###
###########

def printTask(tasks, argv):
    r = process(argv)
    taskid = r["taskid"]
    task= tasks.getTask(taskid)
    if r["restrict"]: task.restrict(tasks.doc, r["restrict"])
    print(etree.tostring(task.toXML(), pretty_print=True))


###############
### Prepare ###
###############

def prepareTask(tasks, argv):
    r = process(argv)
    taskid = r["taskid"]
    task= tasks.getTask(taskid)
    if r["restrict"]: task.restrict(tasks.doc, r["restrict"])
    print(etree.tostring(task.toXML(), pretty_print=True))
    
    doc = tasks.doc
    
    # --- Process documents
    
    documents = task.documents    
    basepath = tasks.getCollectionBasePath(documents.id)
    docfile = os.path.join(absolutePath("cols"), "%s" % documents.id)
    if not os.path.isfile(docfile):
        input = file(os.path.join(absolutePath("docs"), "%s.relfiles" % documents.id),"r")
        out = file(docfile,"w")
        log("Generating the collection file [%s]" % docfile)
        for line in input.readlines():
            out.write(os.path.join(basepath, line))
        out.close()
        input.close()
    
    # --- Get topics
    
    for k,info in { "topics": task.topics, "qrels": task.assessments }.iteritems():
        type = info.url.get("type")
        url = info.url.text
        f = downloadSchemes.get(type, None)
        if f is None:
            raise Exception("Cannot handle [%s]" % type)
            
        if hasattr(info, "origPath") and not info.origPath is None: path = absolutePath(info.origPath)
        else: path = absolutePath(info.path)
            
        if not os.path.exists(path):
            log("Downloading %s %s into [%s]..." % (k, info.id, path))
            createBaseDir(path)
            f[0](path, url, f[1:])
            
        # Restrict if needed
        if hasattr(info, "origPath"):
            path2 = absolutePath(info.path)
            if not os.path.exists(path2):
                createBaseDir(path2)
                info.filter(path, path2)

    
    
def createBaseDir(path):
    dir=os.path.dirname(path)
    if not os.path.isdir(dir): 
        log("Creating directory %s" % dir)
        os.makedirs(dir)

def getTarGZFile(path, url, args):
    """Download QRELS as a set of gzipped files in a tar.gz archive
    """
    tmpdir=None
    try:
        # Temporary directory
        tmpdir=tempfile.mkdtemp()
        tmpfile="%s/file.dl" % tmpdir
        urllib.urlretrieve(url, tmpfile)
        d= "%s/all" % tmpdir
        tarfile.open(tmpfile).extractall(path="%s/all" % tmpdir)
        f_out = open("%s/qrels" % tmpdir, 'w')
        for aPath in (os.path.join(d,f) for f in os.listdir(d)):
            log("Uncompressing %s" % aPath)
            if args[0]: gzf = gzip.open(aPath)
            else: gzf = file(aPath)
            f_out.writelines(gzf)
            gzf.close()
        f_out.close()
        
        # Move in place
        shutil.move("%s/qrels" % tmpdir, path)
        log("Created file %s" % path)
    finally:
        if not tmpdir is None:
            rm_rf(tmpdir)

def getGZFile(path, url, args):
    """Get a GZIPPED file over the network and uncompress it
    """
    gzfile=tempfile.NamedTemporaryFile(delete=True)
    urllib.urlretrieve(url, gzfile.name)

    # Uncompress
    file=tempfile.NamedTemporaryFile(delete=True)
    f = gzip.open(gzfile.name, mode="r")
    file.writelines(f)
    f.close()

    # Move
    log("Uncompressed in %s" % file.name)
    shutil.move(file.name, path)
    log("Created file %s" % path)
    try: file.close()
    except: pass
    try: gzfile.close()
    except: pass

# List of download schemes  
downloadSchemes = {
    "tar.gz#gz" : [getTarGZFile, True],
    "tar.gz" : [getTarGZFile, False],
    "gz" : [getGZFile]
}

############
### Main ###
############

def process(argv):
    try:                  
        r = { "restrict": None, "taskid": None }
        
        opts, args = getopt.getopt(argv, "", ["restrict="])

        for opt,arg in opts:
            if opt in ("--restrict"):
                r["restrict"] = arg
        
        r["taskid"] = args[0]        
        return r
    except getopt.GetoptError:           
        usage()                
        sys.exit(2)


def usage():
    def command(cmd, desc):
        print "%-20s %s" % (cmd, desc)
        
    print "Usage:\n\nircollections [command]"
    print
    print "where command can be:"
    print
    command("help CMD","Give help for the command CMD")
    print
    command("list","List all available tasks")
    command("get","Get the definition of a task")
    command("prepare", "Prepare a task")
    command("evaluate", "Evaluate a run for a given task")
    print
    
def main(dir, argv):
    # Parse command line arguments
    try:                                
        opts, args = getopt.getopt(argv, "hg:d", ["help", "task="])

        for opt,arg in opts:
            if opt in ("-h","--help"):
                usage()
                sys.exit()
    
    except getopt.GetoptError:           
        usage()                
        sys.exit(2)


    
    if len(args) == 0:
        usage()
    else:
            tasks = Tasks(dir)
            
            command = args[0]
            if command == "list":  
                listAllTasks(tasks)
            elif command == "get": 
                printTask(tasks, args[1:])
            elif command == "evaluate":
                raise Exception("Command not yet implemented")
            elif command == "prepare":
                prepareTask(tasks, args[1:])
            else:
                print "Command not recognised (%s)" % command
                usage()
                sys.exit(1)
## except Exception as e:
##     print "Error while running command %s:" % command
##     print e
##     sys.exit(2)


    
# ---- MAIN ----

if __name__ == "__main__":
    main(ircdir, sys.argv[1:])
